{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 169,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import os\n",
    "import math\n",
    "import random \n",
    "\n",
    "import itertools\n",
    "\n",
    "\n",
    "def loadData(directory):\n",
    "    \"\"\"\n",
    "        Takes as input the directory of the dataset. \n",
    "        Outputs two pandas frames: ratings and movies.\n",
    "    \"\"\"\n",
    "    ratings = pd.read_csv(directory + '/ratings.csv', usecols=['userId', 'movieId', 'rating'])\n",
    "    movies = pd.read_csv(directory + 'movies.csv')\n",
    "    return ratings, movies\n",
    "\n",
    "def visualizeData(ratings, movies):\n",
    "    print('Ratings is a {} Frame'.format(ratings.shape))\n",
    "    print(ratings.head())\n",
    "    print('\\n')\n",
    "    print(ratings.describe())\n",
    "    print('\\n')\n",
    "    print('Movies is a {} Frame'.format(movies.shape))\n",
    "    print(movies.head())\n",
    "    \n",
    "    nUsers = len(ratings['userId'].unique())\n",
    "    print(\"There are {} users in the dataset.\".format(nUsers))\n",
    "    nMovies = len(movies['movieId'].unique())\n",
    "    print(\"There are {} movies in the dataset.\".format(nMovies))\n",
    "    \n",
    "    ratings['rating'].hist(bins=50)\n",
    "    \n",
    "def Df2Numpy(ratings):\n",
    "    ratingsMatrix = ratings.pivot(index='userId', columns='movieId', values='rating')\n",
    "    ratingsMatrix = ratingsMatrix.fillna(0)\n",
    "    R = ratingsMatrix.to_numpy()\n",
    "    return R\n",
    "    \n",
    "class MatrixFactorization():\n",
    "    \"\"\"\n",
    "        A Simple Matrix Factorization Class.\n",
    "        Assumes ratings is a n x m Numpy Array. \n",
    "        nFactors is the intermediate dimension k of the Matrices U and V.\n",
    "        lambdaReg and muReg are regularization parameters.\n",
    "        Blabla..\n",
    "    \"\"\"\n",
    "    def __init__(self, ratings, nFactors=10, lambdaReg=0.0, muReg=0.0, alpha=0.01, maxIter=100, epsilon=0.001, trainFrac=0.8, valFrac=0.1, testFrac=0.1):\n",
    "        self.R = ratings\n",
    "        self.nFactors = nFactors\n",
    "        self.lambdaReg = lambdaReg\n",
    "        self.muReg = muReg\n",
    "        self.nUsers, self.nMovies = ratings.shape\n",
    "        self.alpha = alpha\n",
    "        self.maxIter = maxIter\n",
    "        self.U = np.random.normal(size=(self.nUsers, self.nFactors))\n",
    "        self.V = np.random.normal(size=(self.nMovies, self.nFactors))\n",
    "        self.samples = self.matrix2Samples(ratings)\n",
    "        self.epsilon = epsilon\n",
    "        self.trainFrac = trainFrac\n",
    "        self.valFrac = valFrac\n",
    "        self.testFrac = testFrac\n",
    "        \n",
    "    def randomInit(self):\n",
    "        self.U = np.random.normal(size=(self.nUsers, self.nFactors))\n",
    "        self.V = np.random.normal(size=(self.nMovies, self.nFactors))\n",
    "        \n",
    "    def matrix2Samples(self, R):\n",
    "        samples = [(i, j, R[i,j]) for i in range(self.nUsers)\n",
    "           for j in range(self.nMovies) if R[i,j] > 0]\n",
    "        return samples\n",
    "    \n",
    "    def Samples2Matrix(self, samples, m, n):\n",
    "        matrix = np.zeros(m, n)\n",
    "        for s in samples:\n",
    "            i, j, v = s\n",
    "            matrix[i, j] = v\n",
    "        return matrix\n",
    "    \n",
    "    \n",
    "    def splitTrainValTest(self):\n",
    "        # Shuffle the samples and sends back a partition for training, validation and testing\n",
    "        random.shuffle(self.samples)\n",
    "        nSamples = len(self.samples)\n",
    "        e1 = math.floor(self.trainFrac * nSamples)\n",
    "        e2 = math.floor(self.trainFrac * nSamples) + math.floor(self.valFrac * nSamples) \n",
    "        \n",
    "        trainSamples, valSamples, testSamples = self.samples[:e1], self.samples[e1:e2], self.samples[e2:]\n",
    "        \n",
    "        # Check if no lost examples\n",
    "        if nSamples != len(trainSamples) + len(valSamples) + len(testSamples):\n",
    "            print('ERROR')\n",
    "        \n",
    "        return trainSamples, valSamples, testSamples\n",
    "    \n",
    "    def trainValTestIdx(self):\n",
    "        # Returns a partitions of indices \n",
    "        nSamples = len(self.samples)\n",
    "        interval = range(nSamples)\n",
    "        random.shuffle(interval)\n",
    "        \n",
    "        e1 = math.floor(self.trainFrac * nSamples)\n",
    "        e2 = math.floor(self.trainFrac * nSamples) + math.floor(self.valFrac * nSamples) \n",
    "        \n",
    "        trainIdx, valIdx, testIdx = interval[:e1], interval[e1:e2], interval[e2:]\n",
    "        \n",
    "        # Check if no lost examples\n",
    "        if nSamples != len(trainSamples) + len(valSamples) + len(testSamples):\n",
    "            print('ERROR')\n",
    "        \n",
    "        return trainIdx, valIdx, testIdx\n",
    "    \n",
    "    #def stochasticGradientDescentPass(self, R, U, V, alpha, lambdaReg, muReg, nFactors):\n",
    "    #    for i in range(R.shape[0]):\n",
    "    #        for j in range(R.shape[1]):\n",
    "    #            if R[i, j] > 0:\n",
    "    #                r_hat_ij = np.dot(U[i, :], V.T[:, j])\n",
    "    #                eij = R[i, j] - r_hat_ij\n",
    "    #                for q in range(nFactors):\n",
    "    #                    U[i, q] = U[i, q] + alpha * (eij * V[j, q] - lambdaReg * U[i, q])\n",
    "    #                    V[j, q] = V[j, q] + alpha * (eij * U[i, q] - muReg * V[j, q])\n",
    "    #    return U, V\n",
    "\n",
    "    def stochasticGradientDescentPass(self, trainSamples):\n",
    "        for s in trainSamples:\n",
    "            i, j, _ = s\n",
    "            r_hat_ij = np.dot(self.U[i, :], self.V.T[:, j])\n",
    "            eij = self.R[i, j] - r_hat_ij\n",
    "            for q in range(self.nFactors):\n",
    "                self.U[i, q] = self.U[i, q] + self.alpha * (eij * self.V[j, q] - self.lambdaReg * self.U[i, q])\n",
    "                self.V[j, q] = self.V[j, q] + self.alpha * (eij * self.U[i, q] - self.muReg * self.V[j, q])\n",
    "            \n",
    "        return self.U, self.V\n",
    "\n",
    "    def gridSearch(self, factors, alphas, lambdaRegs, muRegs):\n",
    "        lowest_error = math.inf\n",
    "        best_config = None\n",
    "        bestSolution = (None, None)\n",
    "        for config in itertools.product(factors, alphas, lambdaRegs, muRegs):\n",
    "            self.nFactors, self.alpha, self.lambdaReg, self.muReg = config\n",
    "            U, V, history = self.stochasticGradientDescent(False)\n",
    "            if history['valError'] < lowest_error:\n",
    "                lowest_error = history['valError']\n",
    "                best_config = config\n",
    "                bestSolution = (U, V)\n",
    "                \n",
    "        self.U, self.V = bestSolution    # Just for consistency \n",
    "        \n",
    "        return U, V, best_config\n",
    "            \n",
    "            \n",
    "    def stochasticGradientDescent(self, logging=True):\n",
    "        history = {'trainErrors':[], 'valErrors':[]}\n",
    "        self.randomInit()\n",
    "        trainSamples, valSamples, testSamples = self.splitTrainValTest()  # This should probably be outside ?\n",
    "        for i in range(self.maxIter):\n",
    "            # I think we should shuffle the data here. \n",
    "            random.shuffle(trainSamples)\n",
    "            U, V = self.stochasticGradientDescentPass(trainSamples)\n",
    "            trainError = self.computeTotalErrorSamples(trainSamples)\n",
    "            \n",
    "            if logging:\n",
    "                valError = self.computeTotalErrorSamples(valSamples)\n",
    "                history['trainErrors'].append(trainError)\n",
    "                history['valErrors'].append(valError)\n",
    "            if trainError < self.epsilon:\n",
    "                break\n",
    "        \n",
    "        history['trainError'] = self.computeTotalErrorSamples(trainSamples)\n",
    "        history['valError'] = self.computeTotalErrorSamples(valSamples)\n",
    "\n",
    "        return U, V, history\n",
    "\n",
    "\n",
    "    def computeTotalErrorSamples(self, data):\n",
    "        error = 0\n",
    "        for s in data:\n",
    "            i, j, _ = s\n",
    "            error += (R[i, j] - np.dot(self.U[i, :], self.V.T[:, j])) ** 2\n",
    "        return error / len(data)\n",
    "\n",
    "    def plotHistory(self, history): \n",
    "        plt.plot(history['trainErrors'], label='Training Error')\n",
    "        plt.plot(history['valErrors'], label='Validation Error')\n",
    "        plt.title('Evolution of the Loss')\n",
    "        plt.ylabel('Loss Func')\n",
    "        plt.xlabel('Iteration')\n",
    "        plt.legend()\n",
    "        plt.show()\n",
    "        \n",
    "    def computeApproximatedMatrix(self, U, V):\n",
    "        return np.dot(U, V.T)\n",
    "    \n",
    "# Generates a rank(k) matrix. Should add some noise..    \n",
    "def syntheticMatrix(m, n, k):\n",
    "    basis = np.random.randint(3, size=(m, k))\n",
    "    matrix = np.zeros((m, n))\n",
    "    coeffs = np.random.randint(4, size=k)\n",
    "    \n",
    "    for i in range(n):\n",
    "        coeffs = np.random.randint(4, size=k)\n",
    "        matrix[:, i] = sum([coeffs[j] * basis[:, j] for j in range(k)]) # TODO: + some small noise vector\n",
    "         \n",
    "    return matrix\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Ratings is a (100836, 3) Frame\n",
      "   userId  movieId  rating\n",
      "0       1        1     4.0\n",
      "1       1        3     4.0\n",
      "2       1        6     4.0\n",
      "3       1       47     5.0\n",
      "4       1       50     5.0\n",
      "\n",
      "\n",
      "              userId        movieId         rating\n",
      "count  100836.000000  100836.000000  100836.000000\n",
      "mean      326.127564   19435.295718       3.501557\n",
      "std       182.618491   35530.987199       1.042529\n",
      "min         1.000000       1.000000       0.500000\n",
      "25%       177.000000    1199.000000       3.000000\n",
      "50%       325.000000    2991.000000       3.500000\n",
      "75%       477.000000    8122.000000       4.000000\n",
      "max       610.000000  193609.000000       5.000000\n",
      "\n",
      "\n",
      "Movies is a (9742, 3) Frame\n",
      "   movieId                               title  \\\n",
      "0        1                    Toy Story (1995)   \n",
      "1        2                      Jumanji (1995)   \n",
      "2        3             Grumpier Old Men (1995)   \n",
      "3        4            Waiting to Exhale (1995)   \n",
      "4        5  Father of the Bride Part II (1995)   \n",
      "\n",
      "                                        genres  \n",
      "0  Adventure|Animation|Children|Comedy|Fantasy  \n",
      "1                   Adventure|Children|Fantasy  \n",
      "2                               Comedy|Romance  \n",
      "3                         Comedy|Drama|Romance  \n",
      "4                                       Comedy  \n",
      "There are 610 users in the dataset.\n",
      "There are 9742 movies in the dataset.\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "ratings, movies = loadData('Data/')\n",
    "visualizeData(ratings, movies)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 170,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3, 0.01, 0.01, 0.01)\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "R = syntheticMatrix(20, 8, 3)\n",
    "\n",
    "mf = MatrixFactorization(R, nFactors=3, lambdaReg=1.0, muReg=1.0)\n",
    "U, V, best_config = mf.gridSearch(factors=[1, 3, 5, 10], alphas=[0.0001, 0.001, 0.01], lambdaRegs=[0.01, 0.1, 1.0], muRegs=[0.01, 0.1, 1.0])\n",
    "print(best_config)\n",
    "U, V, history = mf.stochasticGradientDescent(True)\n",
    "mf.plotHistory(history)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
